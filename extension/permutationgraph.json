"/// <reference path=\"./cyclicgraph.d.ts\" />\nvar permutationgraph;\n(function (permutationgraph_1) {\n    \"use strict\";\n    class permutationgraphnode {\n        constructor(id) {\n            this.id = id;\n            this.alias = [];\n            this.alias_obj = [];\n            this.dist = 999999999;\n            this.built = false;\n            this.outbound_edges = [];\n            this.inbound_edges = [];\n        }\n        alias_index(context) {\n            var index = -1;\n            for (var k in context) {\n                var v = context[k];\n                index = this.alias_obj.indexOf(v);\n                if (index >= 0) {\n                    break;\n                }\n            }\n            return index;\n        }\n        alias_object(context) {\n            var i = this.alias_index(context);\n            if (i >= 0)\n                return this.alias_obj[i];\n            else\n                return null;\n        }\n        alias_string(context) {\n            var i = this.alias_index(context);\n            if (i >= 0)\n                return this.alias[i];\n            else\n                return '';\n        }\n    }\n    permutationgraph_1.permutationgraphnode = permutationgraphnode;\n    class permutationgraphedge {\n        constructor(origin, destination) {\n            this.alias = '';\n            this.built = false;\n            this.backbone = false;\n            this.destination = destination;\n            this.origin = origin;\n        }\n    }\n    permutationgraph_1.permutationgraphedge = permutationgraphedge;\n    class permutationgraph {\n        constructor(num, size) {\n            if (num < 0)\n                throw (\"Invalid number\");\n            this.num = num;\n            // find minimal size to fit number\n            var min_size = permutationgraph.num_size(num) + 1;\n            this.size = size || min_size;\n            // must have at least size one greater than necessary, to ensure permutation begins with 0\n            if (this.size < min_size)\n                throw \"Size \" + this.size + \" Too small for number \" + this.num;\n            this.makenodes();\n            // make nodes before edges\n            this.makeedges();\n        }\n        // calculates factorial and stores intermediate results in fact\n        static factorial(n) {\n            if (!permutationgraph.fact) {\n                permutationgraph.fact = [1];\n            }\n            for (var i = permutationgraph.fact.length; i <= n; i++) {\n                permutationgraph.fact[i] = i * permutationgraph.fact[i - 1];\n            }\n            return permutationgraph.fact[n];\n        }\n        static fbbhelper(stack, found, size) {\n            var top = stack[stack.length - 1];\n            for (var k in top) {\n                var val = top[k];\n                // skip non objects and numberic keys\n                // numberic keys are not allowed in the backbone\n                if (typeof (val) !== 'object' || /^\\d/.test(k))\n                    continue;\n                var index = stack.indexOf(val);\n                if (index >= 0) {\n                    // cycle found\n                    if (stack.length - index == size) {\n                        console.log(\"found cycle\");\n                        // cycle of length size, save in found array\n                        found.push(stack.slice(index));\n                    }\n                    else {\n                        // found a wrong-length cycle, keep looking\n                        continue;\n                    }\n                }\n                else {\n                    // cycle not yet found\n                    // add item\n                    stack.push(val);\n                    // search further\n                    permutationgraph.fbbhelper(stack, found, size);\n                    // remove item\n                    stack.pop();\n                }\n            }\n        }\n        static findbackbones(root, size) {\n            // find circular paths of length size via depth first search\n            var stack = [];\n            var found = [];\n            stack.push(root);\n            permutationgraph.fbbhelper(stack, found, size);\n            return found;\n        }\n        static findnums(size) {\n            var win = window || {};\n            var backbones = permutationgraph.findbackbones(win, size);\n            var nums = [];\n            for (var i = 0; i < backbones.length; i++) {\n                var backbone = backbones[i];\n                var perm = permutationgraph.backbone_to_perm(backbone);\n                if (perm) {\n                    nums.push(permutationgraph.fact_to_num(permutationgraph.perm_to_fact(perm)));\n                }\n            }\n            return nums;\n        }\n        static backbone_to_perm(backbone) {\n            // check backbone valid if so return permutation represented\n            // else null\n            var size = backbone.length;\n            var perm = [];\n            var i;\n            var i_zero = -1;\n            for (i = 0; i < size; i++) {\n                var obj = backbone[i];\n                var found_backbone_link = false;\n                var val = 0;\n                for (var k in obj) {\n                    var other = obj[k];\n                    var j = backbone.indexOf(other);\n                    if (j >= 0) {\n                        // other in backbone\n                        if (j == i) {\n                            // invalid graph, no nodes link to themselves\n                            console.log(\"self link, discarding backbone\");\n                            return null;\n                        }\n                        else if (!found_backbone_link && j == ((i + 1) % size)) {\n                            found_backbone_link = true;\n                        }\n                        else if (j > i) {\n                            val = j - i;\n                        }\n                        else if (j < i) {\n                            val = size + j - i;\n                        }\n                    }\n                }\n                if (val == 0) {\n                    i_zero = i;\n                }\n                if (perm.indexOf(val) >= 0) {\n                    // already found this edge, invalid permutation graph\n                    console.log(\"invalid permutation, number repeated\");\n                    return null;\n                }\n                perm.push(val);\n            }\n            if (i_zero < 0) {\n                console.log(\"invalid permutation, no zero node\");\n                return null; // should never happen\n            }\n            var perm_reordered = [];\n            for (i = 1; i <= size; ++i) {\n                perm_reordered.push(perm[(i + i_zero) % size]);\n            }\n            console.log(perm_reordered);\n            return perm_reordered;\n        }\n        static num_size(num) {\n            var size = 1;\n            while (num >= permutationgraph.factorial(size)) {\n                size += 1;\n            }\n            return size;\n        }\n        static num_to_fact(num, size) {\n            var fact = [];\n            for (var i = (size || permutationgraph.num_size(num)) - 1; i >= 0; i--) {\n                fact[i] = Math.floor(num / permutationgraph.factorial(i));\n                num -= fact[i] * permutationgraph.factorial(i);\n            }\n            return fact;\n        }\n        static fact_to_num(fact) {\n            var num = 0;\n            for (var i = 0; i < fact.length; i++) {\n                num += fact[i] * permutationgraph.factorial(i);\n            }\n            return num;\n        }\n        // takes an array representing a fact and turns it into the\n        // permutation representation of the factorial number\n        static fact_to_perm(fact) {\n            var perm = fact.slice();\n            for (var i = 1; i < perm.length; i++) {\n                for (var j = 0; j < i; j++) {\n                    if (perm[j] >= perm[i]) {\n                        perm[j]++;\n                    }\n                }\n            }\n            return perm;\n        }\n        // takes an array representing a permutation and turns it into the\n        // factorial representation of the permutation\n        static perm_to_fact(perm) {\n            var fact = perm.slice();\n            for (var i = fact.length - 1; i > 0; i--) {\n                for (var j = 0; j < i; j++) {\n                    if (fact[j] > fact[i]) {\n                        fact[j]--;\n                    }\n                }\n            }\n            return fact;\n        }\n        makenodes() {\n            this.nodes = [];\n            // make nodes\n            for (var i = 0; i < this.size; ++i) {\n                this.nodes.push(new permutationgraphnode(i));\n            }\n        }\n        add_edge(source, destination, backbone) {\n            var edge = new permutationgraphedge(source, destination);\n            edge.backbone = backbone;\n            source.outbound_edges.push(edge);\n            destination.inbound_edges.push(edge);\n            this.num_edges++;\n        }\n        makeedges() {\n            this.num_edges = 0;\n            var size = this.size;\n            var nodes = this.nodes;\n            var perm = permutationgraph.fact_to_perm(permutationgraph.num_to_fact(this.num, this.size));\n            for (var i = 0; i < size; i++) {\n                // make backbone edges\n                this.add_edge(nodes[i], nodes[(i + 1) % size], true);\n                var dest = (i + perm[i]) % size;\n                if (i != dest) {\n                    // edge is not representing zero\n                    this.add_edge(nodes[i], nodes[dest], false);\n                }\n            }\n        }\n        get_node(id) {\n            return this.nodes[id];\n        }\n    }\n    permutationgraph_1.permutationgraph = permutationgraph;\n})(permutationgraph || (permutationgraph = {}));\n"