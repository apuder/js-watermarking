"/// <reference path=\"set_map.d.ts\" />\n/// <reference path=\"./cyclicgraph.d.ts\" />\nvar permutationgraph;\n(function (permutationgraph_1) {\n    \"use strict\";\n    class permutationgraphnode {\n        constructor(id) {\n            this.id = id;\n            this.aliases = new Map();\n            this.alias_obj = new Map();\n            this.dist = Infinity;\n            this.built = Infinity;\n            this.outbound_edges = [];\n            this.inbound_edges = [];\n        }\n        alias_object(context, instruction, building_now) {\n            if (building_now) {\n                for (var k in context) {\n                    var v = context[k];\n                    var node_aliases = this.alias_obj.get(v) || [];\n                    for (var i = 0; i < node_aliases.length; i++) {\n                        var interval = node_aliases[i];\n                        if (instruction >= interval.instruction_added && instruction < interval.instruction_removed)\n                            return interval;\n                    }\n                }\n            }\n            else {\n                for (var k in context) {\n                    var v = context[k];\n                    var node_aliases = this.alias_obj.get(v) || [];\n                    for (var i = 0; i < node_aliases.length; i++) {\n                        var interval = node_aliases[i];\n                        if (instruction > interval.instruction_added && instruction <= interval.instruction_removed)\n                            return interval;\n                    }\n                }\n            }\n            return null;\n        }\n        alias_object_building(context, instruction) {\n            for (var k in context) {\n                var v = context[k];\n                var node_aliases = this.alias_obj.get(v) || [];\n                for (var i = 0; i < node_aliases.length; i++) {\n                    var interval = node_aliases[i];\n                    if (instruction >= interval.instruction_added && instruction < interval.instruction_removed)\n                        return interval;\n                }\n            }\n            return null;\n        }\n    }\n    permutationgraph_1.permutationgraphnode = permutationgraphnode;\n    class permutationgraphedge {\n        constructor(origin, destination) {\n            this.alias = '';\n            this.built = Infinity;\n            this.backbone = false;\n            this.destination = destination;\n            this.origin = origin;\n        }\n    }\n    permutationgraph_1.permutationgraphedge = permutationgraphedge;\n    class permutationgraph {\n        constructor(num, size) {\n            if (num < 0)\n                throw (\"Invalid number\");\n            this.num = num;\n            // find minimal size to fit number\n            var min_size = permutationgraph.num_size(num) + 1;\n            this.size = size || min_size;\n            // must have at least size one greater than necessary, to ensure permutation begins with 0\n            if (this.size < min_size)\n                throw \"Number \" + this.num + \" too large for size \" + this.size;\n            this.makenodes();\n            // make nodes before edges\n            this.makeedges();\n        }\n        // calculates factorial and stores intermediate results in fact\n        static factorial(n) {\n            if (!permutationgraph.fact) {\n                permutationgraph.fact = [1];\n            }\n            for (var i = permutationgraph.fact.length; i <= n; i++) {\n                permutationgraph.fact[i] = i * permutationgraph.fact[i - 1];\n            }\n            return permutationgraph.fact[n];\n        }\n        static findnums(cycles) {\n            // find all numbers represented by permutation graphs in cycles\n            var nums = [];\n            for (var i = 0; i < cycles.length; i++) {\n                var backbone = cycles[i];\n                var perm = permutationgraph.backbone_to_perm(backbone);\n                if (perm) {\n                    nums.push({ num: permutationgraph.fact_to_num(permutationgraph.perm_to_fact(perm)), size: perm.length });\n                    console.log('found watermark number: ' + nums[nums.length - 1].num + ' (size: ' + nums[nums.length - 1].size + ')');\n                }\n            }\n            return nums;\n        }\n        static backbone_to_perm(backbone) {\n            // check backbone valid if so return permutation represented\n            // else null\n            var begin_digit = /^\\d/;\n            var size = backbone.length;\n            var perm = [];\n            var i;\n            var i_zero = -1;\n            // console.log(backbone.length, backbone)\n            for (i = 0; i < size; i++) {\n                var obj = backbone[i];\n                var val = 0;\n                for (var k in obj) {\n                    var other = obj[k];\n                    var j = backbone.indexOf(other);\n                    if (j >= 0) {\n                        // other in backbone\n                        if (j == i) {\n                            // invalid graph, no nodes link to themselves\n                            // console.log(\"self link, discarding backbone\");\n                            return null;\n                        }\n                        if (begin_digit.test(k)) {\n                            // data link, record value\n                            if (j > i) {\n                                val = j - i;\n                            }\n                            else if (j < i) {\n                                val = size + j - i;\n                            }\n                        }\n                    }\n                }\n                if (val == 0) {\n                    i_zero = i;\n                }\n                if (perm.indexOf(val) >= 0) {\n                    // already found this edge, invalid permutation graph\n                    // console.log(\"invalid permutation, number repeated\", perm);\n                    return null;\n                }\n                perm.push(val);\n            }\n            if (i_zero < 0) {\n                // console.log(\"invalid permutation, no zero node\");\n                return null; // should never happen\n            }\n            var perm_reordered = [];\n            for (i = 0; i < size; ++i) {\n                perm_reordered[size - i - 1] = perm[(i + i_zero) % size];\n            }\n            return perm_reordered;\n        }\n        static num_size(num) {\n            var size = 1;\n            while (num >= permutationgraph.factorial(size)) {\n                size += 1;\n            }\n            return size;\n        }\n        static num_to_fact(num, size) {\n            var fact = [];\n            for (var i = (size || permutationgraph.num_size(num)) - 1; i >= 0; i--) {\n                fact[i] = Math.floor(num / permutationgraph.factorial(i));\n                num -= fact[i] * permutationgraph.factorial(i);\n            }\n            return fact;\n        }\n        static fact_to_num(fact) {\n            var num = 0;\n            for (var i = 0; i < fact.length; i++) {\n                num += fact[i] * permutationgraph.factorial(i);\n            }\n            return num;\n        }\n        // takes an array representing a fact and turns it into the\n        // permutation representation of the factorial number\n        static fact_to_perm(fact) {\n            var perm = fact.slice();\n            for (var i = 1; i < perm.length; i++) {\n                for (var j = 0; j < i; j++) {\n                    if (perm[j] >= perm[i]) {\n                        perm[j]++;\n                    }\n                }\n            }\n            return perm;\n        }\n        // takes an array representing a permutation and turns it into the\n        // factorial representation of the permutation\n        static perm_to_fact(perm) {\n            var fact = perm.slice();\n            for (var i = fact.length - 1; i > 0; i--) {\n                for (var j = 0; j < i; j++) {\n                    if (fact[j] > fact[i]) {\n                        fact[j]--;\n                    }\n                }\n            }\n            return fact;\n        }\n        makenodes() {\n            this.nodes = [];\n            // make nodes\n            for (var i = 0; i < this.size; ++i) {\n                this.nodes.push(new permutationgraphnode(i));\n            }\n        }\n        add_edge(source, destination, backbone) {\n            var edge = new permutationgraphedge(source, destination);\n            edge.backbone = backbone;\n            source.outbound_edges.push(edge);\n            destination.inbound_edges.push(edge);\n            this.num_edges++;\n        }\n        makeedges() {\n            this.num_edges = 0;\n            var size = this.size;\n            var nodes = this.nodes;\n            var perm = permutationgraph.fact_to_perm(permutationgraph.num_to_fact(this.num, this.size));\n            for (var i = 0; i < size; i++) {\n                // make backbone edges\n                this.add_edge(nodes[i], nodes[(i + 1) % size], true);\n                var dest = (i + perm[size - i - 1]) % size;\n                if (i != dest) {\n                    // edge is not representing zero\n                    this.add_edge(nodes[i], nodes[dest], false);\n                }\n            }\n        }\n        get_node(id) {\n            return this.nodes[id];\n        }\n    }\n    permutationgraph_1.permutationgraph = permutationgraph;\n})(permutationgraph || (permutationgraph = {}));\n/// <reference path=\"./set_map.d.ts\" />\n/// <reference path=\"./cyclicgraph.d.ts\" />\nvar cyclicgraphinstructions;\n(function (cyclicgraphinstructions_1) {\n    \"use strict\";\n    class cyclicgraphinstructions {\n        constructor(graph) {\n            this.graph = graph;\n            this.size = graph.num_edges + 1;\n            this.fringe_edge = new Set();\n        }\n        // breadth randomely\n        possible(nodes) {\n            var fringe = [];\n            for (var i in nodes) {\n                var edges = nodes[i].outbound_edges;\n                for (var j in edges) {\n                    var e = edges[j];\n                    if (e.built >= Infinity) {\n                        fringe.push(e);\n                    }\n                }\n            }\n            return fringe;\n        }\n        reset_dist() {\n            for (var i in this.graph.nodes) {\n                this.graph.nodes[i].dist = Infinity;\n            }\n        }\n        fringe_add_all(fringe) {\n            for (var i in this.graph.nodes) {\n                fringe.add(this.graph.nodes[i]);\n            }\n        }\n        fringe_min(fringe) {\n            var obj = undefined;\n            var d = Infinity;\n            for (var v of fringe.values()) {\n                if (v.dist < d) {\n                    d = v.dist;\n                    obj = v;\n                }\n            }\n            return obj;\n        }\n        shortest_path(node, context, instruction, building_now) {\n            if (Object.keys(context).length == 0) {\n                return [];\n            }\n            this.reset_dist();\n            var fringe = new Set();\n            fringe.add(node);\n            node.dist = 0;\n            var path = [];\n            var check_inst = instruction + (building_now ? 1 : 0);\n            while (fringe.size > 0) {\n                // find min, remove from fringe\n                var n = this.fringe_min(fringe);\n                fringe.delete(n);\n                var node_alias = n.alias_object(context, instruction, building_now);\n                if (node_alias) {\n                    path.first = n;\n                    path.first_obj = node_alias.obj;\n                    break; // found\n                }\n                // update\n                for (var j in n.inbound_edges) {\n                    var e = n.inbound_edges[j];\n                    if (e.built < check_inst && e.origin.built < check_inst && e.origin.dist > n.dist + 1) {\n                        // add on first encounter\n                        if (!fringe.has(e.origin))\n                            fringe.add(e.origin);\n                        e.origin.dist = n.dist + 1;\n                    }\n                }\n            }\n            if (!path.first)\n                return path;\n            var closest = path.first;\n            while (closest.dist > 0) {\n                for (var i in closest.outbound_edges) {\n                    var e = closest.outbound_edges[i];\n                    if (e.built < check_inst && e.destination.dist == closest.dist - 1) {\n                        closest = e.destination;\n                        path.push(e);\n                        break;\n                    }\n                }\n            }\n            return path;\n        }\n        add_edges_fringe(node) {\n            for (var k in node.outbound_edges) {\n                var edge = node.outbound_edges[k];\n                if (edge.built >= Infinity)\n                    this.fringe_edge.add(edge);\n            }\n        }\n        remove_edge_fringe(edge) {\n            if (this.fringe_edge.has(edge))\n                this.fringe_edge.delete(edge);\n        }\n        add_node_alias(node, obj, alias, instruction) {\n            var node_aliases = node.alias_obj.get(obj);\n            if (!node_aliases) {\n                node_aliases = [];\n                node.alias_obj.set(obj, node_aliases);\n            }\n            node_aliases.push({\n                name: alias,\n                obj: obj,\n                instruction_added: instruction,\n                instruction_removed: Infinity\n            });\n        }\n        remove_node_alias_obj(node, obj, instruction) {\n            var node_alias = node.alias_object([obj], instruction, false);\n            if (node_alias) {\n                node_alias.instruction_removed = instruction;\n            }\n        }\n        consume_node(node, instruction) {\n            if (node.built >= Infinity) {\n                node.built = instruction;\n                this.add_edges_fringe(node);\n            }\n        }\n        consume_edge(edge, alias, instruction) {\n            edge.built = instruction;\n            edge.alias = alias;\n            this.remove_edge_fringe(edge);\n        }\n    }\n    cyclicgraphinstructions_1.cyclicgraphinstructions = cyclicgraphinstructions;\n})(cyclicgraphinstructions || (cyclicgraphinstructions = {}));\n/// <reference path=\"./set_map.d.ts\" />\n/// <reference path=\"./cyclicgraphinstructions.ts\" />\nvar cyclicgraphinserter;\n(function (cyclicgraphinserter_1) {\n    \"use strict\";\n    class cyclicgraphinserter {\n        constructor(instructions) {\n            this.instructions = instructions;\n        }\n        static rand_from_array(col) {\n            var i = Math.floor(Math.random() * col.length);\n            return col[i];\n        }\n        static rand_from_obj(obj) {\n            var keys = Object.keys(obj);\n            var key = cyclicgraphinserter.rand_from_array(keys);\n            var value = obj[key];\n            return { 'key': key, 'value': value };\n        }\n        static rand_from_set(set) {\n            var m = Math.floor(Math.random() * set.size);\n            var i = 0;\n            var thing;\n            for (let item of set) {\n                if (i == m) {\n                    thing = item;\n                    break;\n                }\n                i++;\n            }\n            return thing;\n        }\n        add_inst_to_common_context(inst, obj) {\n            var context = this.common_context.get(obj);\n            if (context) {\n                context.push(inst);\n            }\n            else {\n                context = [inst];\n                context.obj = obj;\n                this.common_context.set(obj, context);\n            }\n        }\n        construct_common_contexts(trace) {\n            this.common_context = new Map();\n            for (var inst = 0; inst < trace.length; inst++) {\n                var context = trace[inst].context;\n                var keys = Object.keys(context);\n                if (keys.length == 0) {\n                    this.add_inst_to_common_context(inst, null);\n                }\n                for (var key in keys) {\n                    this.add_inst_to_common_context(inst, context[key]);\n                }\n            }\n        }\n        assign_code_sites(trace) {\n            var ordered_contexts = [];\n            for (var val of this.common_context.values()) {\n                ordered_contexts.push(val);\n            }\n            // sort decreasing order by length\n            // with lonely contexts at the end (contexts without any objects ///jsw (blank))\n            ordered_contexts.sort(function (a, b) {\n                return (b.obj ? b.length : 0) - (a.obj ? a.length : 0);\n            });\n            this.chosen_contexts = [];\n            this.chosen_contexts.size = 0;\n            var num_instruct = this.instructions.size;\n            var used_instances = new Set();\n            for (var c = 0; c < ordered_contexts.length; c++) {\n                var used_locations = new Set();\n                var common_context = ordered_contexts[c];\n                var chosen_context = [];\n                chosen_context.obj = common_context.obj;\n                this.chosen_contexts.push(chosen_context);\n                for (var j = 0; j < common_context.length; j++) {\n                    var inst = common_context[j];\n                    // check if instance already used\n                    if (used_instances.has(inst))\n                        continue;\n                    else\n                        used_instances.add(inst);\n                    var loc = trace[inst].location;\n                    // check if location used already\n                    if (used_locations.has(loc))\n                        continue;\n                    else\n                        used_locations.add(loc);\n                    // new location to add code\n                    chosen_context.push(inst);\n                    if (++this.chosen_contexts.size >= num_instruct) {\n                        break; // more sites than instructions, stop\n                    }\n                }\n            }\n        }\n        static num_instruct(i, n, p) {\n            var m = Math.floor(n / p);\n            if (i < n - m * p)\n                m++;\n            return m;\n        }\n        static get_obj_alias(obj) {\n            var alias = '';\n            // get used keys for this object\n            var keys = cyclicgraphinserter.used_obj_keys.get(obj);\n            if (!keys) {\n                // keys for this object not registered, register keys\n                keys = {};\n                var keys_arr = Object.keys(obj);\n                for (var k in keys_arr) {\n                    keys[k] = true;\n                }\n                cyclicgraphinserter.used_obj_keys.set(obj, keys);\n            }\n            while (!alias) {\n                alias = cyclicgraphinserter.rand_from_array(cyclicgraphinserter.dictionary);\n                if (keys[alias])\n                    alias = '';\n            }\n            keys[alias] = true; // set key so it can't be used again\n            return '.' + alias;\n        }\n        static reset_obj_keys() {\n            cyclicgraphinserter.used_obj_keys = new Map();\n        }\n        static get_edge_alias(edge) {\n            var alias = '';\n            if (edge.backbone) {\n                // find name\n                while (!alias) {\n                    alias = cyclicgraphinserter.rand_from_array(cyclicgraphinserter.dictionary);\n                    for (var k in edge.origin.outbound_edges) {\n                        var e = edge.origin.outbound_edges[k];\n                        if (e.alias === alias) {\n                            alias = '';\n                            break;\n                        }\n                    }\n                }\n                alias = '.' + alias;\n            }\n            else {\n                // give number\n                var n = 0;\n                while (!alias) {\n                    alias = \"[\" + n + \"]\";\n                    for (var k in edge.origin.outbound_edges) {\n                        var e = edge.origin.outbound_edges[k];\n                        if (e.alias === alias) {\n                            alias = '';\n                            n++;\n                            break;\n                        }\n                    }\n                }\n            }\n            return alias;\n        }\n        // find name (alias) of obj in context\n        static context_obj_alias(obj, context) {\n            for (var k in context) {\n                if (context[k] == obj)\n                    return k;\n            }\n            return '';\n        }\n        static code_from_idiom(check, set) {\n            var code = '';\n            if (check) {\n                code += \"if (\" + check + \") {\\n\";\n                code += \"\\t\" + set + \"\\n\";\n                code += \"}\\n\";\n            }\n            else {\n                code += set + \"\\n\";\n            }\n            return code;\n        }\n        // all of path must be valid as of instruction\n        // num_check is the number of edges to check\n        static valid_path_check(trace, path, context, checked, check_set, instruction) {\n            if (!path.first)\n                return '';\n            var code = '';\n            var part = '';\n            part += cyclicgraphinserter.context_obj_alias(path.first_obj, context) || cyclicgraphinserter.context_obj_alias(path.first_obj, trace.global_context);\n            var alias = path.first.alias_object([path.first_obj], instruction, check_set);\n            part += alias ? alias.name : '';\n            if (alias && checked.get(alias) != path.first) {\n                code += part;\n                checked.set(alias, path.first); // checking external alias node now\n            }\n            var i;\n            var num_check = check_set ? path.length - 1 : path.length;\n            for (i = 0; i < num_check; i++) {\n                var edge = path[i];\n                part += edge.alias;\n                if (!checked.get(edge)) {\n                    code += (code ? ' && ' : '') + part;\n                    checked.set(edge, true); // checking edge now\n                }\n            }\n            if (check_set) {\n                if (path.length == 0) {\n                    // making edge from external object to a node, always check\n                    checked.set(path.first, true); // making node now\n                    code = '!' + part;\n                }\n                else {\n                    // making edge from node to node\n                    var edge = path[i];\n                    part += edge.alias;\n                    if (!checked.get(edge.origin)) {\n                        // no need to check edges of nodes made during these instructions\n                        code += (code ? ' && ' : '') + '!' + part;\n                    }\n                    checked.set(edge, true); // making edge now\n                    checked.set(edge.destination, true); // making node now\n                }\n            }\n            return code;\n        }\n        // parts of path may have been constructed during current instruction\n        // make paths to check existance of all nodes and edges\n        check_path(trace, path, context, checked, check_set, instruction) {\n            if (!path || !path.first)\n                return '';\n            var code = '';\n            var last_built = -3;\n            var tmp_path = [];\n            if (path.first.alias_object([path.first_obj], instruction, false)) {\n                // alias already built to first\n                last_built = -2;\n                if (path.first.built < instruction) {\n                    // first node built, keep checking\n                    // on built run\n                    last_built = -1;\n                    tmp_path.first = path.first;\n                    tmp_path.first_obj = path.first_obj;\n                }\n                else {\n                    // alias was built, but node hasn't been built\n                    console.error(\"alias found for unbuilt node\");\n                }\n            }\n            else {\n                // alias not built, start unbuilt run\n                if (path.first.built < instruction) {\n                    // first node built, keep checking\n                    // incoming alias unbuilt, start built run\n                    // make tmp path to this node\n                    tmp_path = this.instructions.shortest_path(path.first, context, instruction, false);\n                    if (!tmp_path.first)\n                        tmp_path = this.instructions.shortest_path(path.first, trace.global_context, instruction, false);\n                    last_built = -1;\n                }\n                else {\n                }\n            }\n            var i;\n            var num_check = check_set ? path.length - 1 : path.length;\n            for (i = 0; i < num_check; i++) {\n                var edge = path[i];\n                if (edge.built < instruction) {\n                    // path built at edge, keep checking until unbuilt\n                    if (last_built == 2 * i - 1) {\n                        // on built run, grow tmp_path\n                        tmp_path.push(edge);\n                    }\n                    else {\n                        // origin node unbuilt, yet edge built\n                        // should never happen as can't build edge from unbuilt node\n                        console.error(\"edge built before origin node built\");\n                    }\n                    last_built = 2 * i;\n                }\n                else {\n                    // path unbuilt at edge, keep checking until built\n                    if (last_built == 2 * i - 1) {\n                        // origin node was built, end built run\n                        // test path up to this point\n                        var new_code = cyclicgraphinserter.valid_path_check(trace, tmp_path, context, checked, false, instruction);\n                        if (new_code)\n                            code += (code ? ' && ' : '') + new_code;\n                    }\n                    else {\n                    }\n                }\n                var next_node = edge.destination;\n                if (next_node.built < instruction) {\n                    // path built at destination of edge, keep checking\n                    if (last_built == 2 * i) {\n                    }\n                    else {\n                        // incoming edge unbuilt, start built run\n                        // make tmp path to this node\n                        tmp_path = this.instructions.shortest_path(next_node, context, instruction, false);\n                        if (!tmp_path.first)\n                            tmp_path = this.instructions.shortest_path(next_node, trace.global_context, instruction, false);\n                    }\n                    last_built = 2 * i + 1;\n                }\n                else {\n                    // path unbuilt at destination of edge, keep checking till find next built node\n                    if (last_built == 2 * i) {\n                        // incoming edge built, yet node unbuilt\n                        // should never happen as can't build edge to unbuilt node\n                        console.error(\"edge built before destination node built\");\n                    }\n                    else {\n                    }\n                }\n            }\n            if (last_built == 2 * i - 1) {\n                // last node was built, can check it\n                if (check_set) {\n                    // this is a set check,\n                    // ensure last edge not valid\n                    if (path.length > 0) {\n                        // add last edge to path\n                        tmp_path.push(path[i]);\n                    }\n                }\n                var new_code = cyclicgraphinserter.valid_path_check(trace, tmp_path, context, checked, check_set, instruction);\n                if (new_code)\n                    code += (code ? ' && ' : '') + new_code;\n            }\n            else if (check_set && path.length == 0 && path.first.alias_object([path.first_obj], instruction, true) && path.first.built == instruction) {\n                // check direct set not already done\n                var new_code = cyclicgraphinserter.valid_path_check(trace, path, context, checked, check_set, instruction);\n                if (new_code)\n                    code += (code ? ' && ' : '') + new_code;\n            }\n            return code;\n        }\n        code_check(trace, instruct, checked, instruction) {\n            var code = '';\n            // if (instruct.alias_obj) {\n            // \tvar path: cyclicgraphinstructions.path_type = [];\n            // \tvar set_path = instruct.path_set;\n            // \tpath.first = set_path.length > 0 ? set_path[set_path.length - 1].destination : set_path.first;\n            // \tpath.first_obj = instruct.alias_obj;\n            // \tcode += this.check_path(trace, path, instruct.inst.context, checked, true, instruction);\n            // }\n            var new_code = this.check_path(trace, instruct.path_get, instruct.inst.context, checked, false, instruction);\n            if (new_code)\n                code += (code ? ' && ' : '') + new_code;\n            new_code = this.check_path(trace, instruct.path_set, instruct.inst.context, checked, true, instruction);\n            if (new_code)\n                code += (code ? ' && ' : '') + new_code;\n            return code;\n        }\n        static path_code(path, set_path, trace, context, instruction) {\n            if (!path.first)\n                return '';\n            var code = '';\n            code += cyclicgraphinserter.context_obj_alias(path.first_obj, context) || cyclicgraphinserter.context_obj_alias(path.first_obj, trace.global_context);\n            code += path.first.alias_object([path.first_obj], instruction, set_path).name;\n            for (var i = 0; i < path.length; i++) {\n                var edge = path[i];\n                code += edge.alias;\n            }\n            return code;\n        }\n        static code_instruct(instruct, trace, instruction) {\n            var alias = instruct.alias_str;\n            var set = cyclicgraphinserter.path_code(instruct.path_set, true, trace, instruct.inst.context, instruction);\n            var get = instruct.path_get ? cyclicgraphinserter.path_code(instruct.path_get, false, trace, instruct.inst.context, instruction) : \"{}\";\n            var code = alias + set + ' = ' + get + ';\\n';\n            return code;\n        }\n        code_instructions(instructions, trace, inst, instruction) {\n            var location = trace[inst.instance].location;\n            var code = (this.loc_code[location] || '');\n            var check = '';\n            var set = '';\n            var checked = new Map();\n            for (var i = 0; i < instructions.length; i++) {\n                var instruct = instructions[i];\n                var check_i = this.code_check(trace, instruct, checked, instruction);\n                var set_i = cyclicgraphinserter.code_instruct(instruct, trace, instruction + i);\n                if (check_i)\n                    check += (check ? ' && ' : '') + check_i;\n                set += set_i;\n            }\n            code += cyclicgraphinserter.code_from_idiom(check, set);\n            this.loc_code[location] = code;\n        }\n        add_node(edge, trace, inst, instruction) {\n            var path_set;\n            if (edge) {\n                var origin = edge.origin;\n                // find path to origin\n                path_set = this.instructions.shortest_path(origin, inst.context, instruction, false);\n                if (!path_set.first)\n                    path_set = this.instructions.shortest_path(origin, trace.global_context, instruction, false);\n                if (!path_set.first)\n                    console.log(\"failed to find path to node \" + origin.id);\n                var node = edge.destination;\n                var alias = cyclicgraphinserter.get_edge_alias(edge);\n                // consume and alias edge and node\n                this.instructions.consume_edge(edge, alias, instruction);\n                this.instructions.consume_node(node, instruction);\n                // add edge to end of path\n                path_set.push(edge);\n            }\n            else {\n                // pick a single global to refer to root\n                var glob = cyclicgraphinserter.rand_from_obj(trace.global_context);\n                var node = this.instructions.graph.nodes[0];\n                // generate alias for node\n                var alias = cyclicgraphinserter.get_obj_alias(glob.value);\n                // add alias before finding path\n                this.instructions.add_node_alias(node, glob.value, alias, instruction);\n                this.instructions.consume_node(node, instruction);\n                // find path to node using edge just added by adding 1 to instruction (only 1 path possible)\n                // avoid manually constructing path by doing this\n                path_set = [];\n                path_set.first = node;\n                path_set.first_obj = glob.value;\n            }\n            return {\n                inst: inst,\n                alias_str: '',\n                alias_obj: null,\n                path_get: null,\n                path_set: path_set\n            };\n        }\n        add_edge(edge, trace, inst, instruction) {\n            var origin = edge.origin;\n            var destination = edge.destination;\n            // find paths to destination and origin\n            var path_get = this.instructions.shortest_path(destination, inst.context, instruction, false);\n            if (!path_get.first)\n                path_get = this.instructions.shortest_path(destination, trace.global_context, instruction, false);\n            if (!path_get.first)\n                console.log(\"failed to find path to node \" + destination.id);\n            if (path_get.length > 0 && path_get[path_get.length - 1] == edge) {\n                console.error(\"get path uses edge currently being built\");\n            }\n            var path_set = this.instructions.shortest_path(origin, inst.context, instruction, false);\n            if (!path_set.first)\n                path_set = this.instructions.shortest_path(origin, trace.global_context, instruction, false);\n            if (!path_set.first)\n                console.log(\"failed to find path to node \" + origin.id);\n            // alias and consume after finding a path\n            var alias = cyclicgraphinserter.get_edge_alias(edge);\n            // consume and alias edge\n            this.instructions.consume_edge(edge, alias, instruction);\n            // add edge to end of set path\n            path_set.push(edge);\n            return {\n                inst: inst,\n                alias_str: '',\n                alias_obj: null,\n                path_get: path_get,\n                path_set: path_set\n            };\n        }\n        add_alias(curr_instr, inst, force, instruction) {\n            if (Object.keys(inst.context).length == 0) {\n                return;\n            }\n            // get the node that will be aliased\n            var path_set = curr_instr.path_set;\n            var node;\n            if (path_set.length > 0) {\n                node = path_set[path_set.length - 1].destination;\n            }\n            else {\n                node = path_set.first;\n            }\n            if (force ||\n                path_set.length > 2) {\n            }\n            else {\n                // don't alias\n                return;\n            }\n            // check not already aliased by an object in current context\n            if (node.alias_object(inst.context, instruction, true)) {\n                return;\n            }\n            // pick a single object to hold alias\n            var local_obj = cyclicgraphinserter.rand_from_obj(inst.context);\n            // generate alias for node\n            var alias_str = cyclicgraphinserter.get_obj_alias(local_obj.value);\n            this.instructions.add_node_alias(node, local_obj.value, alias_str, instruction);\n            curr_instr.alias_str = local_obj.key + alias_str + \" = \";\n            curr_instr.alias_obj = local_obj.value;\n        }\n        handle_instance(trace, inst, instruction, num_instruct) {\n            if (num_instruct <= 0)\n                return;\n            var instructions = [];\n            for (var num_done = 0; num_done < num_instruct; num_done++) {\n                var curr_instr;\n                var curr_instruction = instruction + num_done;\n                if (curr_instruction == 0) {\n                    // make first node\n                    curr_instr = this.add_node(null, trace, inst, curr_instruction);\n                }\n                else {\n                    var edge = cyclicgraphinserter.rand_from_set(this.instructions.fringe_edge);\n                    if (edge.destination.built < curr_instruction) {\n                        // make edge only\n                        curr_instr = this.add_edge(edge, trace, inst, curr_instruction);\n                    }\n                    else {\n                        // make edge to new node\n                        curr_instr = this.add_node(edge, trace, inst, curr_instruction);\n                    }\n                }\n                // add local alias\n                this.add_alias(curr_instr, inst, curr_instruction == 0 || (num_done == 0 && num_instruct > 2), curr_instruction);\n                instructions.push(curr_instr);\n            }\n            this.code_instructions(instructions, trace, inst, instruction);\n        }\n        construct_site_code(trace) {\n            this.construct_common_contexts(trace);\n            this.assign_code_sites(trace);\n            this.chosen_instances = [];\n            for (var i = 0; i < this.chosen_contexts.length; i++) {\n                var context = this.chosen_contexts[i];\n                for (var j = 0; j < context.length; j++) {\n                    var instance = context[j];\n                    this.chosen_instances.push({ 'instance': instance, 'context': trace[instance].context });\n                }\n            }\n            // sort in increasing order\n            this.chosen_instances.sort(function (a, b) {\n                return a.instance - b.instance;\n            });\n            this.loc_code = [];\n            cyclicgraphinserter.reset_obj_keys();\n            // handle instances in order\n            var instruction = 0;\n            for (var i = 0; i < this.chosen_instances.length; i++) {\n                var inst = this.chosen_instances[i];\n                var num_instruct = cyclicgraphinserter.num_instruct(i, this.instructions.size, this.chosen_contexts.size);\n                this.handle_instance(trace, inst, instruction, num_instruct);\n                instruction += num_instruct;\n            }\n        }\n        insert(trace) {\n            var this_ = this;\n            this.construct_site_code(trace);\n            this.count = 0;\n            return trace.orig_code.replace(/\\/\\/\\/jsw.*/g, function replace(code) {\n                if (code.indexOf(\"\\/\\/\\/jsw_end\") == 0) {\n                    return '';\n                }\n                else if (code.indexOf(\"\\/\\/\\/jsw_global\") == 0) {\n                    return '';\n                }\n                else {\n                    return this_.loc_code[this_.count++] || '';\n                }\n            });\n        }\n        ;\n    }\n    cyclicgraphinserter.dictionary = [\n        'next',\n        'prev',\n        'previous',\n        'self',\n        'mpx',\n        'stack',\n        'tree',\n        'heap',\n        'other',\n        'tmp',\n        'value',\n        'check',\n        'result',\n        'status',\n        'current',\n        'last',\n        'pos',\n        'rest',\n        'before',\n        'after',\n        'gry',\n        'car',\n        'cdr',\n        'head',\n        'aware',\n        'miyabi',\n        'yugen',\n        'wabi',\n        'sabi',\n        'tsukimi'\n    ];\n    cyclicgraphinserter.used_obj_keys = new Map();\n    cyclicgraphinserter_1.cyclicgraphinserter = cyclicgraphinserter;\n})(cyclicgraphinserter || (cyclicgraphinserter = {}));\n/// <reference path=\"./permutationgraph.ts\" />\n/// <reference path=\"./cyclicgraphinstructions.ts\" />\n/// <reference path=\"./cyclicgraphinserter.ts\" />\nvar watermarkapplier;\n(function (watermarkapplier) {\n    \"use strict\";\n    function apply_watermark(trace) {\n        try {\n            var graph = new permutationgraph.permutationgraph(trace.watermark_num, trace.watermark_size);\n            var inst = new cyclicgraphinstructions.cyclicgraphinstructions(graph);\n            var inserter = new cyclicgraphinserter.cyclicgraphinserter(inst);\n            var code = inserter.insert(trace);\n            // console.log(code);\n            window.postMessage({\n                type: \"jsw_inserted_watermark\",\n                text: code,\n                file: trace.file_name,\n                number: trace.watermark_num,\n                size: trace.watermark_size\n            }, \"*\");\n        }\n        catch (e) {\n            window.postMessage({\n                type: \"jsw_insertion_error\",\n                text: e.toString(),\n                file: trace.file_name,\n                number: trace.watermark_num,\n                size: trace.watermark_size\n            }, \"*\");\n        }\n    }\n    watermarkapplier.apply_watermark = apply_watermark;\n})(watermarkapplier || (watermarkapplier = {}));\n"